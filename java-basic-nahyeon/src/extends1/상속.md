# 상속

## 상속 관계

상속은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 기존 클래스의 필드와 메서드를 새로운 클래스에서 **재사용**하게 해준다.

이름 그대로 기존 클래스의 속성과 기능을 물려받는 것이다.

`extends`키워드를 사용하여 상속할 수 있다.

**`extends`의 대상은 하나만 선택할 수 있다.**

- 부모 클래스 (슈퍼 클래스)
  - 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
  - 부모 자체는 자식에 대한 정보는 하나도 없다
- 자식 클래스 (서브 클래스)
  - 부모 클래스로부터 필드와 메서드를 상속받는 클래스

## 단일 상속

> 자바는 다중 상속을 지원하지 않는다. 즉, 하나의 자식이 두 개의 부모를 가지지는 못한다.  
> (`extends` 대상은 하나만 선택할 수 있다.)

다중 상속을 사용하면 클래스 계층 구조가 매우 복잡해 질 수 있고, 여러 모호한 문제를 가지기 때문이다.

자바에서는 인터페이스의 다중 구현을 허용해서 이러한 문제를 피한다.


## 상속과 메모리 구조 (중요!)

```java
ElectricCar electricCar = new ElectricCar();
```
![인스턴스 생성 시 메모리 구조](img.png)

`new ElectricCar()` 를 호출하면 `ElectricCar` 뿐만 아니라 상속 관계에 있는 `Car` 까지 함께 포함해서 인스턴스를 생성한다.  

참조값은 `x001` 로 하나이지만 실제로 그 안에서는 `Car` , `ElectricCar` 라는 두가지 클래스 정보가 공존하는 것이다.  
외부에서 볼때는 하나의 인스턴스를 생성하는 것 같지만 내부에서는 **부모와 자식이 모두 생성되고** 공간도 구분된다.
 

### 자신의 메서드 호출 시

> 본인 타입에서 먼저 찾는다.

**`electricCar.charge()` 호출** 

![메서드 호출 시 메모리](img_1.png)

상속 관계의 경우에는 내부에 부모와 자식이 모두 존재한다.  
이때 부모인 `Car` 를 통해서 `charge()` 를 찾을지 아니면 `ElectricCar` 를 통해서 `charge()` 를 찾을지 선택해야 한다.
이때는 **호출하는 변수의 타입(클래스)을 기준으로 선택**한다.  

`electricCar` 변수의 타입이 `ElectricCar` 이므로 인스턴스 내부에 같은 타입인 `ElectricCar` 를 통해서 `charge()` 를 호출한다.

### 부모의 메서드 호출 시

> 본인 타입에서 먼저 찾고 (없을테니까) 이후 부모 타입에서 찾는다.

**`electricCar.move()` 호출**

![부모의 메서드 호출 시 메모리](img_2.png)

`ElectricCar` 에는 `move()` 메서드가 없다.  

상속 관계에서는 자식 타입에 해당 기능이 없으면 부모 타입으로 올라가서 찾는다.  
이 경우 `ElectricCar` 의 부모인 `Car` 로 올라가서 `move()` 를 찾는다.  
부모인 `Car` 에 `move()` 가 있으므로 부모에 있는 `move()` 메서드를 호출한다.  

만약 부모에서도 해당 기능을 찾지 못하면 더 상위 부모에서 필요한 기능을 찾아본다. 부모에 부모로 계속 올라가면서 필드나 메서드를 찾는 것이다. 물론 계속 찾아도 없으면 **컴파일 오류**가 발생한다.

### 상속과 메모리 구조 정리

- 상속 관계의 객체를 생성하면 그 **내부에는 부모와 자식이 모두 생성**된다.
- 상속 관계의 객체를 호출할 때, `대상 타입`을 정해야 한다. 이때 **호출자의 타입을 통해 `대상 타입`을 찾는다.**
- 현재 타입에서 기능을 **찾지 못하면 상위 부모 타입으로** 기능을 찾아서 실행한다. 기능을 찾지 못하면 **컴파일 오류**가 발생한다.


